<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var cleaning_1 = require("./cleaning");
var uuid_1 = require("uuid");
var convert_1 = require("./convert");
exports.upgrade = convert_1.upgrade;
/**
 * Creates a Map notebook representation from any given JSON representation
 * of a notebook.
 * @param {any} notebookJS - The notebook to be converted.
 * @return {Map&lt;string, any>} The Map notebook representation in JSON.
 */
function fromJS(notebookJS) {
    // TODO: Check the version of the notebook and convert it to the expected
    // version for in memory operations.
    var immnb = cleaning_1.cleanMultilineNotebook(immutable_1.fromJS(notebookJS));
    var cellData = {};
    return immnb
        .set('cellOrder', immnb.get('cells').map(function (cell) {
        var id = uuid_1.v4();
        cellData[id] = cell;
        return id;
    }))
        .remove('cells')
        .set('cellMap', immutable_1.fromJS(cellData));
}
exports.fromJS = fromJS;
/**
 * Creates an JSON representation of a notebook from the Map notebook
 * representation.
 * @param {Map&lt;string, any>} notebook - A notebook in its Map representation.
 * @return {const} Notebook in its JSON.
 */
function toJS(notebook) {
    return cleaning_1.makeMultilineNotebook(notebook
        .set('cells', notebook
        .get('cellOrder', immutable_1.List())
        .map(function (id) {
        return notebook.getIn(['cellMap', id], immutable_1.fromJS({}));
    }))
        .remove('cellOrder')
        .remove('cellMap'))
        .toJS();
}
exports.toJS = toJS;
/** Exports a Map representation of an empty Notebook from its JSON */
exports.emptyNotebook = fromJS({
    cells: [],
    nbformat: 4,
    nbformat_minor: 0,
});
/** Exports a Map representation of a markdown cell from its JSON. */
exports.emptyMarkdownCell = immutable_1.fromJS({
    cell_type: 'markdown',
    metadata: {},
    source: '',
});
/** Exports a Map representation of an empty  code cell from its JSON. */
exports.emptyCodeCell = immutable_1.fromJS({
    cell_type: 'code',
    execution_count: null,
    metadata: {
        collapsed: false,
    },
    source: '',
    outputs: [],
});
/**
 * Inserts a cell into a Map notebook representation.
 * @param {Map&lt;string, any>} notebook - The notebook in its Map representation that one wants to insert a cell into.
 * @param {Map&lt;string, any>} cell - The Map JSON representation of a cell to be inserted.
 * @param {string} cellID - A Universally Unique Identifier given to cell to be inserted.
 * @param {number} index - The index of cellOrder List to insert UUID into, determining where cell will appear.
 * @return {Map&lt;string, any>} The original notebook with the inserted cell.
 */
function insertCellAt(notebook, cell, cellID, index) {
    return notebook.setIn(['cellMap', cellID], cell)
        .set('cellOrder', notebook.get('cellOrder').insert(index, cellID));
}
exports.insertCellAt = insertCellAt;
/**
 * Inserts a cell into a Map notebook representation given the previous cell.
 * @param {Map&lt;string, any>} notebook - The notebook in its Map representation that one wants to insert a cell into.
 * @param {Map&lt;string, any>} cell - The Map representation of a cell to be inserted.
 * @param {string} cellID - A Universally Unique Identifier given to cell to be inserted.
 * @param {string} priorCellID - The UUID of the cell that will precede the cell to be inserted.
 * @return {Map&lt;string, any>} The original notebook with the inserted cell.
 */
function insertCellAfter(notebook, cell, cellID, priorCellID) {
    return insertCellAt(notebook, cell, cellID, notebook.get('cellOrder').indexOf(priorCellID) + 1);
}
exports.insertCellAfter = insertCellAfter;
/**
 * Appends a cell to the end of the list of cells in a Map notebook representation.
 * @param {Map&lt;string, any>} notebook - The notebook in its Map representation that one wants to append a cell to.
 * @param {Map&lt;string, any>} cell - The Map representation of a cell to be inserted.
 * @param {string} cellID - A Universally Unique Identifier given to cell to be inserted,
 * it is generated by a call to uuid() upon calling the function.
 * @return {Map&lt;string, any>} The original notebook with the inserted cell.
 */
function appendCell(notebook, cell, cellID) {
    if (cellID === void 0) { cellID = uuid_1.v4(); }
    return notebook.setIn(['cellMap', cellID], cell)
        .set('cellOrder', notebook.get('cellOrder').push(cellID));
}
exports.appendCell = appendCell;
/**
 * Changes source to be executed by notebook to a given string.
 * @param {Map&lt;string, any>} notebook - The notebook in its Map representation
 * that contains a cell with source desired to be changed.
 * @param {string} cellID - A Universally Unique Identifier given to cell to be modified.
 * @param {string} source - The source code or markdown to be given to a cell by the
 * function.
 * @return {Map&lt;string, any>} The original notebook updated with the updated cell.
 */
function updateSource(notebook, cellID, source) {
    return notebook.setIn(['cellMap', cellID, 'source'], source);
}
exports.updateSource = updateSource;
/**
 * Clears any output that an individual cell in a notebook has recorded.
 * @param  {Map&lt;string, any>} notebook - The notebook in its Map representation
 * that contains a cell with output desired to be removed.
 * @param {string} cellID - A Universally Unique Identifier given to the cell to be modified.
 * @return {Map&lt;string, any>} The original notebook with the output-removed cell.
 */
function clearCellOutput(notebook, cellID) {
    return notebook.setIn(['cellMap', cellID, 'outputs'], immutable_1.List());
}
exports.clearCellOutput = clearCellOutput;
/**
 * Updates output that an individual cell in a notebook has recorded with a
 * provided list of outputs.
 * @param  {Map&lt;string, any>} notebook - The notebook in its Map representation that
 * contains a cell with output desired to be updated.
 * @param {string} cellID - A Universally Unique Identifier given to the cell to be modified.
 * @param {List&lt;Map&lt;string, any>>} outputs - List of key value pairs to be added
 * outputs list.
 * @return {Map&lt;string, any>} The original notebook with the output-updated cell.
 */
function updateOutputs(notebook, cellID, outputs) {
    return notebook.setIn(['cellMap', cellID, 'outputs'], outputs);
}
exports.updateOutputs = updateOutputs;
/**
 * Updates number of times that an individual cell in a notebook has been executed
 * with a provided number.
 * @param  {Map&lt;string, any>} notebook - The notebook in its Map representation
 * that contains a cell with execution count desired to be updated.
 * @param {string} cellID - A Universally Unique Identifier given to the cell to be modified.
 * @param {number} count - Number of the times the cell has been executed.
 * @return {Map&lt;string, any>} The original notebook with the execution count updated cell.
 */
function updateExecutionCount(notebook, cellID, count) {
    return notebook.setIn(['cellMap', cellID, 'execution_count'], count);
}
exports.updateExecutionCount = updateExecutionCount;
/**
 * Removes a cell from a given notebook given the UUID of the cell.
 * @param  {Map&lt;string, any>} notebook - The notebook in its Map representation
 * that contains a cell that is to be removed.
 * @param {string} cellID - A Universally Unique Identifier given to the cell to be removed.
 * @return {Map&lt;string, any>} The original notebook with the removed cell.
 */
function removeCell(notebook, cellId) {
    return notebook
        .removeIn(['cellMap', cellId])
        .update('cellOrder', function (cellOrder) { return cellOrder.filterNot(function (id) { return id === cellId; }); });
}
exports.removeCell = removeCell;
/**
 * Removes a cell from a given notebook given the index in the cellOrder.
 * @param  {Map&lt;string, any>} notebook - the notebook in its Map representation
 * that contains a cell that is to be removed.
 * @param {number} index - The index of the cell in the cellOrder list such that
 * it can be removed.
 * @return {Map&lt;string, any>} The original notebook with the removed cell.
 */
function removeCellAt(notebook, index) {
    return removeCell(notebook, notebook.getIn(['cellOrder', index]));
}
exports.removeCellAt = removeCellAt;
/**
 * Splits a given cell into two cells at the given position.
 * @param {Map&lt;string, any>} notebook - the notebook in its Map representation
 * @param {string} cellID - A UUID given to the cell to be split
 * @param {number} position - The position in the source to split at
 */
function splitCell(notebook, cellID, position) {
    var cell = notebook.getIn(['cellMap', cellID]);
    var cellSource = cell.get('source');
    var first = cellSource.slice(0, position);
    var second = cellSource.slice(position, cellSource.length);
    var newCell = exports.emptyCodeCell.set('source', second);
    var newCellID = uuid_1.v4();
    return notebook
        .setIn(['cellMap', cellID, 'source'], first)
        .setIn(['cellMap', newCellID], newCell)
        .set('cellOrder', notebook.get('cellOrder').push(newCellID));
}
exports.splitCell = splitCell;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#appendCell">appendCell</a></li><li><a href="global.html#breakIntoMultiline">breakIntoMultiline</a></li><li><a href="global.html#cleanMultiline">cleanMultiline</a></li><li><a href="global.html#cleanMultilineNotebook">cleanMultilineNotebook</a></li><li><a href="global.html#clearCellOutput">clearCellOutput</a></li><li><a href="global.html#emptyCodeCell">emptyCodeCell</a></li><li><a href="global.html#emptyMarkdownCell">emptyMarkdownCell</a></li><li><a href="global.html#emptyNotebook">emptyNotebook</a></li><li><a href="global.html#fromJS">fromJS</a></li><li><a href="global.html#insertCellAfter">insertCellAfter</a></li><li><a href="global.html#insertCellAt">insertCellAt</a></li><li><a href="global.html#makeMultilineNotebook">makeMultilineNotebook</a></li><li><a href="global.html#processCell">processCell</a></li><li><a href="global.html#processCells">processCells</a></li><li><a href="global.html#processOutputData">processOutputData</a></li><li><a href="global.html#processOutputs">processOutputs</a></li><li><a href="global.html#removeCell">removeCell</a></li><li><a href="global.html#removeCellAt">removeCellAt</a></li><li><a href="global.html#repeat">repeat</a></li><li><a href="global.html#splitCell">splitCell</a></li><li><a href="global.html#toJS">toJS</a></li><li><a href="global.html#updateExecutionCount">updateExecutionCount</a></li><li><a href="global.html#updateOutputs">updateOutputs</a></li><li><a href="global.html#updateSource">updateSource</a></li><li><a href="global.html#upgraders">upgraders</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Mar 15 2017 16:43:04 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
